# export_youtube_cookies.py
# Improved Selenium exporter for YouTube cookies (Netscape cookies.txt)
# Works best on desktop Chrome. Save and run with: python export_youtube_cookies.py

import os
import time
from webdriver_manager.chrome import ChromeDriverManager
from selenium import webdriver
from selenium.webdriver.chrome.options import Options

# -------------------- CONFIG --------------------
# If you want to reuse your actual Chrome profile (recommended for longevity),
# set USE_EXISTING_PROFILE = True and update EXISTING_USER_DATA_DIR below.
# Otherwise a fresh profile will be created in ./chrome_profile (safer for beginners).
USE_EXISTING_PROFILE = False
EXISTING_USER_DATA_DIR = r"C:\Users\marku\Downloads\User Data"  # <-- change if you want to reuse your profile

OUTPUT_FILENAME = "cookies_youtube.txt"
CHECK_INTERVAL = 2          # seconds between checks for cookies
MAX_WAIT_SECONDS = 600      # how long to wait for you to login manually (10 minutes)
# ------------------------------------------------

def build_driver():
    options = Options()

    # Use a real desktop user-agent so Google treats it like desktop Chrome
    options.add_argument(
        "user-agent=Mozilla/5.0 (Windows NT 10.0; Win64; x64) "
        "AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36"
    )

    # Use an explicit persistent profile folder (either your real one or a local folder)
    if USE_EXISTING_PROFILE and os.path.isdir(EXISTING_USER_DATA_DIR):
        options.add_argument(f"--user-data-dir={EXISTING_USER_DATA_DIR}")
        print(f"[info] Using existing Chrome profile: {EXISTING_USER_DATA_DIR}")
    else:
        profile_dir = os.path.join(os.getcwd(), "chrome_profile")
        os.makedirs(profile_dir, exist_ok=True)
        options.add_argument(f"--user-data-dir={profile_dir}")
        print(f"[info] Using local profile folder: {profile_dir}")

    # anti-detection switches
    options.add_experimental_option("excludeSwitches", ["enable-automation"])
    options.add_experimental_option("useAutomationExtension", False)

    # not headless (so you can solve verification if Google asks)
    # options.add_argument("--headless=new")  # DO NOT enable headless for initial login

    # helpful flags
    options.add_argument("--no-sandbox")
    options.add_argument("--disable-dev-shm-usage")
    options.add_argument("--disable-blink-features=AutomationControlled")
    options.add_argument("--start-maximized")

    driver = webdriver.Chrome(ChromeDriverManager().install(), options=options)

    # Inject JS to reduce navigator.webdriver and other fingerprints
    driver.execute_cdp_cmd(
        "Page.addScriptToEvaluateOnNewDocument",
        {
            "source": """
            // Pass the webdriver check
            Object.defineProperty(navigator, 'webdriver', {get: () => undefined});
            // Pass Chrome headless checks
            window.chrome = { runtime: {} };
            // Permissions mock
            const originalQuery = window.navigator.permissions.query;
            window.navigator.permissions.query = (parameters) => (
              parameters.name === 'notifications' ?
                Promise.resolve({ state: Notification.permission }) :
                originalQuery(parameters)
            );
            """
        },
    )

    return driver

def has_good_youtube_cookies(cookie_list):
    # look for the important cookie names used by YouTube/Google sessions
    names = {c.get("name", "") for c in cookie_list}
    # tokens that typically indicate a full login session
    needed = ["SID", "HSID", "__Secure-3PSID", "__Secure-1PAPISID", "__Secure-3PAPISID", "__Secure-1PSID"]
    # succeed if we find at least one of the strong session cookies OR SID family
    if any(n in names for n in needed):
        return True
    # some accounts show different cookies â€” also accept LOGIN_INFO or SAPISID pair
    if "LOGIN_INFO" in names or "SAPISID" in names:
        return True
    return False

def save_netscape_cookies(cookies, path):
    """
    Write cookies to Netscape format (cookies.txt) which yt-dlp / curl can read.
    Ensures domains start with a dot for cross-subdomain cookies when appropriate.
    """
    lines = []
    lines.append("# Netscape HTTP Cookie File")
    lines.append("# This file was generated by export_youtube_cookies.py")
    lines.append("# https://curl.haxx.se/rfc/cookie_spec.html")
    lines.append("")
    for c in cookies:
        domain = c.get("domain", "")
        # Chrome sometimes returns domains like "www.youtube.com" or ".youtube.com"
        if domain and not domain.startswith(".") and "." in domain:
            domain = "." + domain
        include_subdomains = "TRUE" if domain.startswith(".") else "FALSE"
        path_cookie = c.get("path", "/")
        secure = "TRUE" if c.get("secure", False) else "FALSE"
        expiry = c.get("expiry") or c.get("expires") or 0
        try:
            expiry = int(expiry)
        except Exception:
            expiry = 0
        name = c.get("name", "")
        value = c.get("value", "")
        lines.append("\t".join([domain, include_subdomains, path_cookie, secure, str(expiry), name, value]))
    with open(path, "w", encoding="utf-8") as f:
        f.write("\n".join(lines))
    return path

def main():
    print("Starting Chrome... a window will open. Please login to YouTube in that window if required.")
    driver = build_driver()
    try:
        driver.get("https://www.youtube.com")
    except Exception as e:
        print("[error] Could not open YouTube:", e)
        driver.quit()
        return

    start = time.time()
    print("If a Google verification (captcha / confirm it's you) appears, solve it in the opened browser.")
    print(f"Waiting up to {MAX_WAIT_SECONDS} seconds for login cookies...")

    # Wait until we detect good cookies or timeout
    while True:
        cookies = driver.get_cookies()
        if has_good_youtube_cookies(cookies):
            # refresh once to ensure latest cookies set server-side
            driver.refresh()
            time.sleep(1)
            cookies = driver.get_cookies()
            if has_good_youtube_cookies(cookies):
                print("[ok] Login cookies detected.")
                break
        elapsed = time.time() - start
        if elapsed > MAX_WAIT_SECONDS:
            print("[timeout] Did not detect expected cookies within the timeout.")
            print("You can either: (1) finish manual login in the opened Chrome window and rerun this script,")
            print("(2) set USE_EXISTING_PROFILE = True to reuse your desktop profile, or")
            print("(3) increase MAX_WAIT_SECONDS.")
            driver.quit()
            return
        time.sleep(CHECK_INTERVAL)

    # Save cookies to Netscape file
    output_path = os.path.join(os.getcwd(), OUTPUT_FILENAME)
    path = save_netscape_cookies(cookies, output_path)
    print(f"[saved] Cookies written to: {path}")
    print("Test with (example):")
    print(f'python -m yt_dlp --cookies "{path}" -F "https://www.youtube.com/watch?v=dQw4w9WgXcQ"')
    driver.quit()


if __name__ == "__main__":
    main()
